#!/bin/sh
#
# 2014 Steven Armstrong (steven-cdist at armstrong.cc)
#
# This file is part of cdist.
#
# cdist is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cdist is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cdist. If not, see <http://www.gnu.org/licenses/>.
#

file="$(cat "$__object/parameter/file")"
state="$(cat "$__object/parameter/state")"
mkdir "$__object/files"

_cksum() {
   echo "$1" | cksum | cut -d' ' -f 1
}

_do_line() {
   file="$1"
   line="$2"
   state="$3"
   line_id="$(_cksum "$file")-$(_cksum "$line")"

   set -- "$line_id"
   set -- "$@" --file "$file"
   set -- "$@" --line "$line"
   set -- "$@" --state "$state"
   # Ensure __line does not read stdin
   __line "$@" < /dev/null
}

# Generate the entry as it should be
(
   if [ -f "$__object/parameter/option" ]; then
      options="$(cat "$__object/parameter/option" | tr '\n' ',')"
      printf '%s ' "${options%*,}"
   fi
   if [ -f "$__object/parameter/comment" ]; then
      # extract the keytype and base64 encoded key ignoring any options and comment
      printf '%s ' "$(cat "$__object/parameter/key" | tr ' ' '\n' | awk '/^(ssh|ecdsa)-[^ ]+/ { printf $1" "; getline; printf $1 }')"
      # override the comment with the one explicitly given
      printf '%s' "$(cat "$__object/parameter/comment")"
   else
      printf '%s' "$(cat "$__object/parameter/key")"
   fi
) > "$__object/files/should"

# Check for existing and conflicting entries and remove them
if [ -s "$__object/explorer/entry" ]; then
   # We have existing entries for this key.
   # Check if any of them are in conflict to how the entry should be.
   # Note that the file has to be sorted for comparison with `comm`.
   sort "$__object/explorer/entry" > "$__object/files/is"
   comm -13 "$__object/files/should" "$__object/files/is" | {
      # Remove conflicting entries
      while read entry; do
         _do_line "$file" "$entry" absent
      done
   }
fi

# Manage the actual entry as it should be
entry="$(cat "$__object/files/should")"
_do_line "$file" "$entry" "$state"
